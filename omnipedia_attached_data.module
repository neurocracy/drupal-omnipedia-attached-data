<?php

declare(strict_types=1);

use Drupal\Component\Render\MarkupInterface;
use Drupal\Core\Database\Query\AlterableInterface;
use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements \hook_help().
 */
function omnipedia_attached_data_help(
  string $routeName, RouteMatchInterface $routeMatch
): MarkupInterface|array|string {

  return \Drupal::service('omnipedia_attached_data.help')->help(
    $routeName, $routeMatch
  );

}

/**
 * Implements \hook_query_alter().
 *
 * This limits entity queries tagged with
 * 'non_overlapping_entity_date_range_validate' to only search for attached
 * data entities that also have the same type and target values as the one being
 * validated.
 */
function omnipedia_attached_data_query_alter(AlterableInterface $query): void {

  if (!$query->hasTag('non_overlapping_entity_date_range_validate')) {
    return;
  }

  /** @var \Drupal\omnipedia_date\Entity\EntityWithDateRangeInterface */
  $entity = $query->getMetaData('entity_validate');

  if ($entity->getEntityTypeId() !== 'omnipedia_attached_data') {
    return;
  }

  // Note that we need to prefix the fields with the 'base_table' alias to avoid
  // potential fatal errors like this:
  //
  // "Drupal\Core\Database\IntegrityConstraintViolationException: SQLSTATE[23000]: Integrity constraint violation: 1052 Column 'type' in where clause is ambiguous"
  $query
    ->condition('base_table.type',   $entity->type->value)
    ->condition('base_table.target', $entity->target->value);

}
